import React, { useEffect, useMemo, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from "@/components/ui/command";
import { Loader2, LogIn, Settings, Filter, ListChecks, ClipboardCheck, PlayCircle, ChevronRight, ChevronLeft, ShieldCheck, X } from "lucide-react";
import { motion } from "framer-motion";
// Genesys Cloud Platform SDK (browser)
import * as platformClient from "purecloud-platform-client-v2";

/**
 * Quality Policy Wizard â€“ Client App (Single-file demo)
 *
 * NOTE: Converted to plain React (no TypeScript syntax) to resolve build errors.
 * - Removed TS types and casts
 * - Ensured all JSX blocks are properly closed
 * - Kept shadcn/ui components and overall structure
 * - Added lightweight self-tests for helpers (run from a button in Step 5)
 */

// ----------------------- Helpers (no TS) -----------------------

function groupBy(arr, key) {
  return arr.reduce((acc, item) => {
    const k = (item[key] || "unknown");
    if (!acc[k]) acc[k] = [];
    acc[k].push(item);
    return acc;
  }, {});
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function toIntervalUTC(fromDate, toDate){
  return `${fromDate}T00:00:00.000Z/${toDate}T23:59:59.999Z`;
}

// ----------------------- Genesys Cloud SDK & API glue -----------------------

let GC_BASE = "";
let GC_TOKEN = "";

async function sdkLoginImplicitGrant(clientId, region){
  const client = platformClient.ApiClient.instance;
  GC_BASE = `https://api.${region}`;
  client.setEnvironment(region);
  client.setPersistSettings(true, "custom-quality-policy");
  const redirectUri = window.location.origin + window.location.pathname;
  await client.loginImplicitGrant(clientId, redirectUri, { state: "qpw" });
  GC_TOKEN = client.authData.accessToken;
  const me = await apiFetch("/api/v2/users/me");
  return { id: me.id, name: me.name, email: me.email };
}

function buildUrl(path, query){
  const q = new URLSearchParams();
  if (query) {
    Object.entries(query).forEach(([k, v]) => {
      if (v === undefined || v === null) return;
      if (Array.isArray(v)) v.forEach(val => q.append(k, String(val)));
      else q.append(k, String(v));
    });
  }
  const qs = q.toString();
  return `${GC_BASE}${path}${qs ? `?${qs}` : ""}`;
}

async function apiFetch(path, init){
  const res = await fetch(buildUrl(path), {
    ...init,
    headers: {
      Authorization: `Bearer ${GC_TOKEN}`,
      "Content-Type": "application/json",
      ...(init && init.headers ? init.headers : {})
    }
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> "");
    throw new Error(`API ${path} failed: ${res.status} ${res.statusText} ${text}`);
  }
  if (res.status === 204) return null;
  return res.json();
}

async function getAllPages(path, params = {}, maxPages = 50){
  let pageNumber = params.pageNumber || 1;
  const pageSize = params.pageSize || 100;
  const out = [];
  for (let i=0; i<maxPages; i++) {
    const qs = new URLSearchParams({ ...params, pageNumber: String(pageNumber), pageSize: String(pageSize) });
    const data = await apiFetch(`${path}?${qs}`);
    const entities = (data && (data.entities || data.items)) || [];
    out.push(...entities);
    if (!data || !data.nextUri) break;
    pageNumber++;
  }
  return out;
}

// ---- Lookups (multi-select sources) ----
async function fetchUsers(){
  const entities = await getAllPages("/api/v2/users", { state: "active", pageSize: 100 });
  return entities.map(u => ({ id: u.id, name: u.name, email: u.email }));
}

async function fetchQueues(){
  const entities = await getAllPages("/api/v2/routing/queues", { pageSize: 100 });
  return entities.map(q => ({ id: q.id, name: q.name }));
}

async function fetchEvalForms(){
  const entities = await getAllPages("/api/v2/quality/forms/evaluations", { pageSize: 100 });
  return entities.map(f => ({ id: f.id, name: f.name, versionId: (f && (f.publishedVersion && f.publishedVersion.id)) || (f && f.defaultVersion && f.defaultVersion.id) }));
}

async function fetchTopics(){
  const entities = await getAllPages("/api/v2/speechandtextanalytics/topics", { pageSize: 200 });
  return entities.map(t => ({ id: t.id, label: t.name }));
}

async function fetchCategories(){
  const entities = await getAllPages("/api/v2/speechandtextanalytics/categories", { pageSize: 200 });
  return entities.map(c => ({ id: c.id, label: c.name }));
}

async function fetchSkills(){
  const entities = await getAllPages("/api/v2/routing/skills", { pageSize: 200 });
  return entities.map(s => ({ id: s.id, label: s.name }));
}

async function fetchLanguages(){
  const entities = await getAllPages("/api/v2/routing/languages", { pageSize: 200 });
  return entities.map(l => ({ id: l.id, label: l.name || l.code || l.id }));
}

async function fetchWorkTeams(){
  const entities = await getAllPages("/api/v2/teams", { pageSize: 200 });
  return entities.map(t => ({ id: t.id, label: t.name }));
}

async function fetchTeamMembers(teamId){
  const entities = await getAllPages(`/api/v2/teams/${teamId}/members`, { pageSize: 200 });
  return entities.map(m => (m && m.user && m.user.id) || m.id).filter(Boolean);
}

async function fetchWrapUpCodes(){
  const entities = await getAllPages("/api/v2/routing/wrapupcodes", { pageSize: 200 });
  return entities.map(w => ({ id: w.id, label: w.name }));
}

// ---- Analytics search + optional STA (topics/categories/sentiment) ----
async function runConversationDetailsJob(criteria){
  const interval = toIntervalUTC(criteria.dateFrom, criteria.dateTo);
  const body = {
    interval,
    order: "asc",
    orderBy: "conversationStart",
    startOfDayIntervalMatching: true,
    paging: { pageSize: 1000, pageNumber: 1 },
    conversationFilters: [],
    segmentFilters: []
  };

  if (criteria.queues && criteria.queues.length) {
    body.conversationFilters.push({
      type: "or",
      predicates: criteria.queues.map(id => ({ dimension: "queueId", operator: "matches", value: id }))
    });
  }
  if (criteria.users && criteria.users.length) {
    body.conversationFilters.push({
      type: "or",
      predicates: criteria.users.map(id => ({ dimension: "userId", operator: "matches", value: id }))
    });
  }
  if (criteria.wrapUpCodes && criteria.wrapUpCodes.length) {
    body.segmentFilters.push({
      type: "or",
      predicates: criteria.wrapUpCodes.map(id => ({ dimension: "wrapUpCode", operator: "matches", value: id }))
    });
  }
  if (criteria.direction && criteria.direction !== "both") {
    body.segmentFilters.push({ type: "or", predicates: [{ dimension: "direction", operator: "matches", value: criteria.direction }] });
  }
  if (criteria.mediaType) {
    body.segmentFilters.push({ type: "or", predicates: [{ dimension: "mediaType", operator: "matches", value: criteria.mediaType }] });
  }

  const job = await apiFetch("/api/v2/analytics/conversations/details/jobs", { method: "POST", body: JSON.stringify(body) });
  const jobId = job.id;
  for (let i=0; i<60; i++) {
    const status = await apiFetch(`/api/v2/analytics/conversations/details/jobs/${jobId}`);
    if (status.state === "Succeeded" || status.state === "succeeded" || status.state === "Complete" || status.progress === 100) break;
    await new Promise(r => setTimeout(r, 1000));
  }
  const hits = [];
  let pageNumber = 1;
  while (true) {
    const res = await apiFetch(`/api/v2/analytics/conversations/details/jobs/${jobId}/results?pageSize=200&pageNumber=${pageNumber}`);
    const ents = (res && (res.conversations || res.entities)) || [];
    hits.push(...ents);
    if (!res || !res.nextUri) break;
    pageNumber++;
    if (pageNumber > 50) break;
  }
  return hits;
}

function mapDetailsToHits(rows){
  const out = [];
  for (const r of rows) {
    const conversationId = (r && (r.conversationId || r.id));
    const startTime = (r && (r.conversationStart || r.startTime)) || "";
    let agentId; let queueId; let wrapUpCode; let language; let durationSec;

    const participants = (r && r.participants) || [];
    for (const p of participants) {
      if (!agentId && p && p.purpose === "agent" && p.userId) agentId = p.userId;
      if (!queueId && p && p.queueId) queueId = p.queueId;
      const segs = (p && p.segments) || [];
      for (const s of segs) {
        if (!wrapUpCode && s && s.wrapUpCode) wrapUpCode = s.wrapUpCode;
        if (!durationSec && s && typeof s.segmentDurationMs === "number") durationSec = Math.round(s.segmentDurationMs / 1000);
        if (!language && s && s.language) language = s.language;
      }
    }

    out.push({ conversationId, startTime, agentId, queueId, wrapUpCode, language, durationSec });
  }
  return out;
}

async function transcriptSearchConversationIds(criteria){
  const interval = toIntervalUTC(criteria.dateFrom, criteria.dateTo);
  const clauses = [];
  if (criteria.useSentiment) {
    if (typeof criteria.sentimentMin === "number") clauses.push({ type: "RANGE", field: "overallSentiment", gte: criteria.sentimentMin });
    if (typeof criteria.sentimentMax === "number") clauses.push({ type: "RANGE", field: "overallSentiment", lte: criteria.sentimentMax });
  }
  if (criteria.useTopics && criteria.includeTopics && criteria.includeTopics.length) {
    clauses.push({ type: "TERMS", field: "topicId", values: criteria.includeTopics });
  }
  if (criteria.useTopics && criteria.excludeTopics && criteria.excludeTopics.length) {
    clauses.push({ type: "NOT", clause: { type: "TERMS", field: "topicId", values: criteria.excludeTopics }});
  }
  if (criteria.useCategories && criteria.includeCategories && criteria.includeCategories.length) {
    clauses.push({ type: "TERMS", field: "categoryId", values: criteria.includeCategories });
  }
  if (criteria.useCategories && criteria.excludeCategories && criteria.excludeCategories.length) {
    clauses.push({ type: "NOT", clause: { type: "TERMS", field: "categoryId", values: criteria.excludeCategories }});
  }

  const ids = new Set();
  let pageNumber = 1;
  while (true) {
    const body = { interval, pageNumber, pageSize: 100, query: clauses.length ? { type: "AND", clauses } : undefined, sortOrder: "asc" };
    const res = await apiFetch("/api/v2/speechandtextanalytics/transcripts/search", { method: "POST", body: JSON.stringify(body) });
    const results = (res && (res.conversations || res.results)) || [];
    for (const row of results) {
      const id = (row && (row.conversationId || row.id));
      if (id) ids.add(id);
    }
    if (!res || !res.nextPage) break;
    pageNumber++;
    if (pageNumber > 10) break; // ~1000 total (100/page)
  }
  return ids;
}

async function analyticsSearch(criteria){
  try {
    // Expand work teams into users
    let usersSet = new Set(criteria.users || []);
    if (criteria.workTeams && criteria.workTeams.length) {
      const lists = await Promise.all(criteria.workTeams.map(fetchTeamMembers));
      lists.flat().forEach(id => usersSet.add(id));
    }
    const expandedCriteria = { ...criteria, users: Array.from(usersSet) };

    const rows = await runConversationDetailsJob(expandedCriteria);
    let hits = mapDetailsToHits(rows);

    if (expandedCriteria.direction && expandedCriteria.direction !== "both") {
      // direction per-segment not always exposed in summary; skip if undefined
      hits = hits.filter(h => !expandedCriteria.direction || !h.direction || h.direction === expandedCriteria.direction);
    }
    if (expandedCriteria.languages && expandedCriteria.languages.length) {
      hits = hits.filter(h => h.language && expandedCriteria.languages.includes(h.language));
    }
    if (expandedCriteria.wrapUpCodes && expandedCriteria.wrapUpCodes.length) {
      hits = hits.filter(h => h.wrapUpCode && expandedCriteria.wrapUpCodes.includes(h.wrapUpCode));
    }
    if (typeof expandedCriteria.minDurationSec === "number") {
      hits = hits.filter(h => typeof h.durationSec === "number" && h.durationSec >= expandedCriteria.minDurationSec);
    }
    if (typeof expandedCriteria.maxDurationSec === "number") {
      hits = hits.filter(h => typeof h.durationSec === "number" && h.durationSec <= expandedCriteria.maxDurationSec);
    }
    if (expandedCriteria.users && expandedCriteria.users.length) {
      hits = hits.filter(h => !h.agentId || expandedCriteria.users.includes(h.agentId));
    }
    if (expandedCriteria.queues && expandedCriteria.queues.length) {
      hits = hits.filter(h => !h.queueId || expandedCriteria.queues.includes(h.queueId));
    }

    if (expandedCriteria.useAdvanced && (expandedCriteria.useSentiment || expandedCriteria.useTopics || expandedCriteria.useCategories)) {
      const staIds = await transcriptSearchConversationIds(expandedCriteria);
      hits = hits.filter(h => staIds.has(h.conversationId));
    }

    return hits;
  } catch (err) {
    console.warn("analyticsSearch fallback due to error:", err);
    // Safe demo data fallback
    return [
      { conversationId: "c1", startTime: "2025-09-01T10:00:00Z", agentId: "u1", queueId: "q1", direction: "inbound", sentimentScore: -35, topics: ["Cancellation"], categories: ["Risk"], wrapUpCode: "wu-refund", skills: ["billing"], language: "en-gb", durationSec: 480 },
      { conversationId: "c2", startTime: "2025-09-01T11:00:00Z", agentId: "u2", queueId: "q1", direction: "outbound", sentimentScore: 10, topics: ["Order Status"], categories: ["Info"], wrapUpCode: "wu-order", skills: ["sales"], language: "en-us", durationSec: 300 },
      { conversationId: "c3", startTime: "2025-09-02T09:20:00Z", agentId: "u2", queueId: "q2", direction: "inbound", sentimentScore: -10, topics: ["Escalation"], categories: ["Complaint"], wrapUpCode: "wu-complaint", skills: ["tech"], language: "en-gb", durationSec: 900 },
      { conversationId: "c4", startTime: "2025-09-03T15:42:00Z", agentId: "u3", queueId: "q2", direction: "inbound", sentimentScore: -55, topics: ["Refund"], categories: ["Risk"], wrapUpCode: "wu-refund", skills: ["billing"], language: "en-gb", durationSec: 1200 },
      { conversationId: "c5", startTime: "2025-09-04T08:14:00Z", agentId: "u1", queueId: "q1", direction: "outbound", sentimentScore: 5, topics: ["Tech Support"], categories: ["Info"], wrapUpCode: "wu-order", skills: ["tech"], language: "en-us", durationSec: 180 }
    ];
  }
}

async function createEvaluations(sampled, rules, evaluators){
  const evalIds = [];
  const pool = (rules.evaluatorIds || []).map(id => evaluators.find(e => e.id === id)).filter(Boolean);
  if (!pool.length) throw new Error("No evaluators selected");

  const pairs = [];
  sampled.forEach((s, idx) => {
    const ev = pool[idx % pool.length];
    pairs.push({ convo: s, evaluatorId: ev.id });
  });

  const chunkSize = 10;
  for (let i=0; i<pairs.length; i+=chunkSize) {
    const chunk = pairs.slice(i, i+chunkSize);
    await Promise.all(chunk.map(p => apiFetch("/api/v2/quality/evaluations", {
      method: "POST",
      body: JSON.stringify({
        conversationId: p.convo.conversationId,
        agentUserId: p.convo.agentId,
        evaluatorId: p.evaluatorId,
        formId: rules.evalFormId
      })
    }).catch(e => console.warn("Eval create failed for", p.convo.conversationId, e))));
    evalIds.push(...chunk.map(p => ({ conversationId: p.convo.conversationId, evaluatorId: p.evaluatorId })));
  }

  return { created: evalIds.length, details: evalIds };
}

// ----------------------- UI primitives -----------------------

const Stepper = ({ step, setStep }) => {
  const steps = [
    { n: 1, label: "Login" },
    { n: 2, label: "Criteria" },
    { n: 3, label: "Evaluation Rules" },
    { n: 4, label: "Review" },
    { n: 5, label: "Execute" }
  ];
  return (
    <div className="flex items-center gap-3 mb-6">
      {steps.map((s, idx) => (
        <div key={s.n} className="flex items-center gap-3">
          <button
            className={`text-sm px-3 py-1 rounded-full border ${step === s.n ? "bg-black text-white" : "bg-white"}`}
            onClick={() => setStep(s.n)}
          >
            {s.n}. {s.label}
          </button>
          {idx < steps.length - 1 && <ChevronRight className="w-4 h-4 opacity-60" />}
        </div>
      ))}
    </div>
  );
};

const SplashLogin = ({ onLogin }) => {
  const [loading, setLoading] = useState(false);
  const [clientId, setClientId] = useState("");
  const [region, setRegion] = useState("mypurecloud.com");
  return (
    <Card className="max-w-xl mx-auto shadow-xl border-none">
      <CardContent className="p-10 text-center space-y-6">
        <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }}>
          <h1 className="text-3xl font-semibold mb-2">Custom Quality Policies</h1>
          <p className="text-muted-foreground">Enter your OAuth Client ID, select region, and sign in</p>
        </motion.div>
        <div className="space-y-2 text-left">
          <Label>Client ID</Label>
          <Input value={clientId} onChange={(e)=> setClientId(e.target.value)} placeholder="paste your OAuth client id" />
        </div>
        <div className="space-y-2 text-left">
          <Label>Region</Label>
          <Select value={region} onValueChange={(v)=> setRegion(v)}>
            <SelectTrigger className="mt-2"><SelectValue placeholder="Select region"/></SelectTrigger>
            <SelectContent>
              <SelectItem value="mypurecloud.com">US East (mypurecloud.com)</SelectItem>
              <SelectItem value="usw2.pure.cloud">US West (usw2.pure.cloud)</SelectItem>
              <SelectItem value="cac1.pure.cloud">Canada (cac1.pure.cloud)</SelectItem>
              <SelectItem value="euw2.pure.cloud">EU West (euw2.pure.cloud)</SelectItem>
              <SelectItem value="mypurecloud.ie">EU Ireland (mypurecloud.ie)</SelectItem>
              <SelectItem value="mypurecloud.de">EU Germany (mypurecloud.de)</SelectItem>
              <SelectItem value="aps1.pure.cloud">Asia Pacific (aps1.pure.cloud)</SelectItem>
              <SelectItem value="apne2.pure.cloud">AP Northeast 2 (apne2.pure.cloud)</SelectItem>
              <SelectItem value="apse2.pure.cloud">AP Southeast 2 (apse2.pure.cloud)</SelectItem>
              <SelectItem value="sae1.pure.cloud">South America East (sae1.pure.cloud)</SelectItem>
              <SelectItem value="mypurecloud.jp">Japan (mypurecloud.jp)</SelectItem>
              <SelectItem value="mypurecloud.au">Australia (mypurecloud.au)</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <motion.div initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }}>
          <Button className="w-full" disabled={!clientId} onClick={async () => {
            setLoading(true);
            try {
              const user = await sdkLoginImplicitGrant(clientId.trim(), region);
              onLogin(user);
            } catch (e) {
              alert(`Login failed: ${e && e.message ? e.message : e}`);
            } finally {
              setLoading(false);
            }
          }}>
            {loading ? <Loader2 className="mr-2 h-4 w-4 animate-spin"/> : <LogIn className="mr-2 h-4 w-4"/>}
            Sign in
          </Button>
        </motion.div>
        <div className="text-xs text-muted-foreground flex items-center justify-center gap-2">
          <ShieldCheck className="w-4 h-4"/> OAuth via Platform Client SDK
        </div>
      </CardContent>
    </Card>
  );
};

function useOptionsFrom(data){
  return useMemo(() => (data || []).map(d => ({ id: d.id, label: d.name })), [data]);
}

const MultiSelect = ({ value, onChange, options, placeholder = "Select...", emptyLabel = "No results" }) => {
  const [open, setOpen] = useState(false);
  const [query, setQuery] = useState("");
  const filtered = options
    .filter(o => (o.label || "").toLowerCase().includes(query.toLowerCase()))
    .sort((a,b)=> (a.label || "").localeCompare(b.label || ""));

  const toggle = (id) => {
    if (value.includes(id)) onChange(value.filter(v => v !== id));
    else onChange([...value, id]);
  };

  const remove = (id) => onChange(value.filter(v => v !== id));

  const labelFor = (id) => {
    const found = options.find(o => o.id === id);
    return (found && found.label) || id;
  };

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button variant="outline" className="w-full justify-start min-h-10 flex-wrap">
          {value.length === 0 ? (
            <span className="text-muted-foreground">{placeholder}</span>
          ) : (
            <div className="flex flex-wrap gap-1">
              {value.map(v => (
                <Badge key={v} variant="secondary" className="flex items-center gap-1">
                  {labelFor(v)}
                  <X className="w-3 h-3 cursor-pointer" onClick={(e)=> { e.stopPropagation(); remove(v); }} />
                </Badge>
              ))}
            </div>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="p-0 w-[320px]">
        <Command>
          <CommandInput value={query} onValueChange={setQuery} placeholder="Type to search..." />
          <CommandList>
            <CommandEmpty>{emptyLabel}</CommandEmpty>
            <CommandGroup>
              {filtered.map(opt => (
                <CommandItem key={opt.id} onSelect={() => toggle(opt.id)}>
                  <Checkbox checked={value.includes(opt.id)} className="mr-2" /> {opt.label}
                </CommandItem>
              ))}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
};

const CriteriaStep = ({ criteria, setCriteria, users, queues, topics, categories, skills, languages, workTeams, wrapUps }) => {
  const userOptions = useOptionsFrom(users);
  const queueOptions = useOptionsFrom(queues);
  return (
    <Card className="border-0 shadow-xl">
      <CardContent className="p-6 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <Label>Date range (UTC)</Label>
            <div className="flex gap-3 mt-2">
              <Input type="date" value={criteria.dateFrom} onChange={e => setCriteria({ ...criteria, dateFrom: e.target.value })} />
              <Input type="date" value={criteria.dateTo} onChange={e => setCriteria({ ...criteria, dateTo: e.target.value })} />
            </div>
          </div>
          <div>
            <Label>Media type</Label>
            <Select value={criteria.mediaType} onValueChange={(v) => setCriteria({ ...criteria, mediaType: v })}>
              <SelectTrigger className="mt-2"><SelectValue placeholder="Select"/></SelectTrigger>
              <SelectContent>
                <SelectItem value="voice">Voice</SelectItem>
                <SelectItem value="chat">Chat</SelectItem>
                <SelectItem value="email">Email</SelectItem>
                <SelectItem value="message">Messaging</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div>
            <Label>Direction</Label>
            <Select value={criteria.direction} onValueChange={(v)=> setCriteria({ ...criteria, direction: v })}>
              <SelectTrigger className="mt-2"><SelectValue placeholder="Both"/></SelectTrigger>
              <SelectContent>
                <SelectItem value="both">Both</SelectItem>
                <SelectItem value="inbound">Inbound</SelectItem>
                <SelectItem value="outbound">Outbound</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div>
            <Label>Queues</Label>
            <MultiSelect value={criteria.queues} onChange={(v)=> setCriteria({ ...criteria, queues: v })} options={queueOptions} placeholder="Select queues" />
          </div>
          <div>
            <Label>Agents / Users</Label>
            <MultiSelect value={criteria.users} onChange={(v)=> setCriteria({ ...criteria, users: v })} options={userOptions} placeholder="Select users" />
          </div>
          <div>
            <Label>Work teams</Label>
            <MultiSelect value={criteria.workTeams} onChange={(v)=> setCriteria({ ...criteria, workTeams: v })} options={workTeams} placeholder="Select work teams" />
          </div>
          <div>
            <Label>Wrap-up codes</Label>
            <MultiSelect value={criteria.wrapUpCodes} onChange={(v)=> setCriteria({ ...criteria, wrapUpCodes: v })} options={wrapUps} placeholder="Select wrap-up codes" />
          </div>
          <div>
            <Label>Skills</Label>
            <MultiSelect value={criteria.skills} onChange={(v)=> setCriteria({ ...criteria, skills: v })} options={skills} placeholder="Select skills" />
          </div>
          <div>
            <Label>Languages</Label>
            <MultiSelect value={criteria.languages} onChange={(v)=> setCriteria({ ...criteria, languages: v })} options={languages} placeholder="Select languages" />
          </div>
          <div>
            <Label>Duration (sec)</Label>
            <div className="grid grid-cols-2 gap-2 mt-2">
              <Input type="number" placeholder="Min" value={criteria.minDurationSec ?? ""} onChange={(e)=> setCriteria({ ...criteria, minDurationSec: e.target.value === "" ? undefined : Number(e.target.value) })} />
              <Input type="number" placeholder="Max" value={criteria.maxDurationSec ?? ""} onChange={(e)=> setCriteria({ ...criteria, maxDurationSec: e.target.value === "" ? undefined : Number(e.target.value) })} />
            </div>
          </div>
        </div>

        <div className="pt-4 border-t">
          <div className="flex items-center gap-2">
            <Checkbox checked={criteria.useAdvanced} onCheckedChange={(v) => setCriteria({ ...criteria, useAdvanced: Boolean(v) })} />
            <Label className="text-base font-semibold">Advanced filters (STA)</Label>
          </div>

          {criteria.useAdvanced && (
            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-6">
              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <Checkbox checked={criteria.useSentiment} onCheckedChange={(v) => setCriteria({ ...criteria, useSentiment: Boolean(v) })} />
                  <Label>Sentiment</Label>
                </div>
                {criteria.useSentiment && (
                  <div className="grid grid-cols-2 gap-2">
                    <Input type="number" placeholder="Min (e.g. -100)" value={criteria.sentimentMin ?? ""} onChange={(e)=> setCriteria({ ...criteria, sentimentMin: e.target.value === "" ? undefined : Number(e.target.value)})} />
                    <Input type="number" placeholder="Max (e.g. 100)" value={criteria.sentimentMax ?? ""} onChange={(e)=> setCriteria({ ...criteria, sentimentMax: e.target.value === "" ? undefined : Number(e.target.value)})} />
                  </div>
                )}
              </div>

              <div className="space-y-2">
                <Label>Topics include / exclude</Label>
                <MultiSelect value={criteria.includeTopics} onChange={(v)=> setCriteria({ ...criteria, useTopics: true, includeTopics: v })} options={topics} placeholder="Include topics" />
                <MultiSelect value={criteria.excludeTopics} onChange={(v)=> setCriteria({ ...criteria, useTopics: true, excludeTopics: v })} options={topics} placeholder="Exclude topics" />
              </div>

              <div className="space-y-2">
                <Label>Categories include / exclude</Label>
                <MultiSelect value={criteria.includeCategories} onChange={(v)=> setCriteria({ ...criteria, useCategories: true, includeCategories: v })} options={categories} placeholder="Include categories" />
                <MultiSelect value={criteria.excludeCategories} onChange={(v)=> setCriteria({ ...criteria, useCategories: true, excludeCategories: v })} options={categories} placeholder="Exclude categories" />
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

const EvalRulesStep = ({ rules, setRules, evaluators, forms }) => {
  const evaluatorOptions = useOptionsFrom(evaluators);
  return (
    <Card className="border-0 shadow-xl">
      <CardContent className="p-6 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div className="md:col-span-3">
            <Label>Evaluation type</Label>
            <Select value={rules.mode} onValueChange={(v)=> setRules({ ...rules, mode: v })}>
              <SelectTrigger className="mt-2"><SelectValue placeholder="Select type"/></SelectTrigger>
              <SelectContent>
                <SelectItem value="byAgent">By agent (X per agent)</SelectItem>
                <SelectItem value="randomCount">Random count (global)</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {rules.mode === "byAgent" && (
            <div>
              <Label>Evaluations per agent</Label>
              <Input className="mt-2" type="number" min={1} value={rules.perAgentTarget}
                onChange={(e)=> setRules({ ...rules, perAgentTarget: Math.max(1, Number(e.target.value)) })} />
              <p className="text-xs text-muted-foreground mt-2">Randomly sample per-agent from the candidate pool.</p>
            </div>
          )}

          {rules.mode === "randomCount" && (
            <div>
              <Label>Total evaluations to create</Label>
              <Input className="mt-2" type="number" min={1} value={rules.randomTargetCount}
                onChange={(e)=> setRules({ ...rules, randomTargetCount: Math.max(1, Number(e.target.value)) })} />
              <p className="text-xs text-muted-foreground mt-2">Randomly select from the entire pool, regardless of agent.</p>
            </div>
          )}

          <div>
            <Label>Evaluation form</Label>
            <Select value={rules.evalFormId} onValueChange={(v)=> setRules({ ...rules, evalFormId: v })}>
              <SelectTrigger className="mt-2"><SelectValue placeholder="Select form"/></SelectTrigger>
              <SelectContent>
                {forms.map(f => <SelectItem key={f.id} value={f.id}>{f.name}</SelectItem>)}
              </SelectContent>
            </Select>
          </div>

          <div className="md:col-span-2">
            <Label>Evaluators</Label>
            <MultiSelect value={rules.evaluatorIds} onChange={(v)=> setRules({ ...rules, evaluatorIds: v })} options={evaluatorOptions} placeholder="Select evaluators" />
            <p className="text-xs text-muted-foreground mt-2">Assignments are distributed round-robin across selected evaluators.</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

const ReviewStep = ({ preview, rules, criteria, users, evaluators, forms }) => {
  const form = forms.find(f => f.id === rules.evalFormId);
  return (
    <Card className="border-0 shadow-xl">
      <CardContent className="p-6 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h3 className="text-lg font-semibold mb-2">Criteria</h3>
            <ul className="text-sm space-y-1">
              <li><b>Dates:</b> {criteria.dateFrom} â†’ {criteria.dateTo}</li>
              <li><b>Media:</b> {criteria.mediaType}</li>
              <li><b>Direction:</b> {criteria.direction}</li>
              <li><b>Queues:</b> {criteria.queues.length || "(any)"}</li>
              <li><b>Users:</b> {criteria.users.length || "(any)"}</li>
              <li><b>Work teams:</b> {criteria.workTeams.length || "(any)"}</li>
              <li><b>Wrap-up codes:</b> {criteria.wrapUpCodes.length || "(any)"}</li>
              <li><b>Skills:</b> {criteria.skills.length || "(any)"}</li>
              <li><b>Languages:</b> {criteria.languages.length || "(any)"}</li>
              <li><b>Duration:</b> {(criteria.minDurationSec ?? "-")} to {(criteria.maxDurationSec ?? "-")} sec</li>
              {criteria.useAdvanced && (
                <>
                  <li><b>Sentiment:</b> {criteria.useSentiment ? `${criteria.sentimentMin ?? ""} to ${criteria.sentimentMax ?? ""}` : "(off)"}</li>
                  <li><b>Topics inc/exc:</b> {criteria.includeTopics.length || "-"} / {criteria.excludeTopics.length || "-"}</li>
                  <li><b>Categories inc/exc:</b> {criteria.includeCategories.length || "-"} / {criteria.excludeCategories.length || "-"}</li>
                </>
              )}
            </ul>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Evaluation Rules</h3>
            <ul className="text-sm space-y-1">
              <li><b>Type:</b> {rules.mode === "byAgent" ? `By agent (${rules.perAgentTarget} each)` : `Random count (${rules.randomTargetCount})`}</li>
              <li><b>Form:</b> {form && form.name} ({rules.evalFormId})</li>
              <li><b>Distribution:</b> Round-robin</li>
              <li><b>Evaluators:</b> {rules.evaluatorIds.length}</li>
            </ul>
          </div>
        </div>

        <div className="pt-4 border-t">
          <h3 className="text-lg font-semibold mb-2">Preview</h3>
          {!preview ? (
            <p className="text-sm text-muted-foreground">Run a preview to see candidate and sampled counts.</p>
          ) : (
            <div className="text-sm grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="p-3 rounded-lg bg-muted/40">
                <b>Total candidates:</b> {preview.totalCandidates}
              </div>
              <div className="p-3 rounded-lg bg-muted/40">
                <b>Total sampled:</b> {preview.totalSampled}
              </div>
              {rules.mode === "byAgent" ? (
                <div className="md:col-span-2">
                  {Object.entries(preview.sampledByAgent).map(([agentId, rows]) => (
                    <div key={agentId} className="mb-3 p-3 rounded border">
                      <div className="text-sm font-medium">Agent {agentId} â€“ {rows.length} selected</div>
                      <ul className="text-xs mt-2 space-y-1">
                        {rows.map(r => <li key={r.conversationId}>â€¢ {r.conversationId} ({r.startTime})</li>)}
                      </ul>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="md:col-span-2">
                  <div className="mb-2 text-sm font-medium">Sampled conversations</div>
                  <ul className="text-xs mt-2 space-y-1">
                    {preview.sampledGlobal.map(r => <li key={r.conversationId}>â€¢ {r.conversationId} ({r.startTime})</li>)}
                  </ul>
                </div>
  const evaluatorOptions = useOptionsFrom(evaluators as any);
  return (
    <Card className="border-0 shadow-xl">
      <CardContent className="p-6 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div className="md:col-span-3">
            <Label>Evaluation type</Label>
            <Select value={rules.mode} onValueChange={(v)=> setRules({ ...rules, mode: v as EvalMode })}>
              <SelectTrigger className="mt-2"><SelectValue placeholder="Select type"/></SelectTrigger>
              <SelectContent>
                <SelectItem value="byAgent">By agent (X per agent)</SelectItem>
                <SelectItem value="randomCount">Random count (global)</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {rules.mode === "byAgent" && (
            <div>
              <Label>Evaluations per agent</Label>
              <Input className="mt-2" type="number" min={1} value={rules.perAgentTarget}
                onChange={(e)=> setRules({ ...rules, perAgentTarget: Math.max(1, Number(e.target.value)) })} />
              <p className="text-xs text-muted-foreground mt-2">Randomly sample per-agent from the candidate pool.</p>
            </div>
          )}

          {rules.mode === "randomCount" && (
            <div>
              <Label>Total evaluations to create</Label>
              <Input className="mt-2" type="number" min={1} value={rules.randomTargetCount}
                onChange={(e)=> setRules({ ...rules, randomTargetCount: Math.max(1, Number(e.target.value)) })} />
              <p className="text-xs text-muted-foreground mt-2">Randomly select from the entire pool, regardless of agent.</p>
            </div>
          )}

          <div>
            <Label>Evaluation form</Label>
            <Select value={rules.evalFormId} onValueChange={(v)=> setRules({ ...rules, evalFormId: v })}>
              <SelectTrigger className="mt-2"><SelectValue placeholder="Select form"/></SelectTrigger>
              <SelectContent>
                {forms.map(f => <SelectItem key={f.id} value={f.id}>{f.name}</SelectItem>)}
              </SelectContent>
            </Select>
          </div>

          <div className="md:col-span-2">
            <Label>Evaluators</Label>
            <MultiSelect value={rules.evaluatorIds} onChange={(v)=> setRules({ ...rules, evaluatorIds: v })} options={evaluatorOptions} placeholder="Select evaluators" />
            <p className="text-xs text-muted-foreground mt-2">Assignments are distributed round-robin across selected evaluators.</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

const ReviewStep: React.FC<{ preview: RunPreview | null; rules: EvalRulesState; criteria: CriteriaState; users: User[]; evaluators: Evaluator[]; forms: EvalForm[] }>
= ({ preview, rules, criteria, users, evaluators, forms }) => {
  const form = forms.find(f => f.id === rules.evalFormId);
  const labelize = (ids: string[], pool: Option[]) => ids.map(id => pool.find(p => p.id === id)?.label || id).join(", ");
  return (
    <Card className="border-0 shadow-xl">
      <CardContent className="p-6 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h3 className="text-lg font-semibold mb-2">Criteria</h3>
            <ul className="text-sm space-y-1">
              <li><b>Dates:</b> {criteria.dateFrom} â†’ {criteria.dateTo}</li>
              <li><b>Media:</b> {criteria.mediaType}</li>
              <li><b>Direction:</b> {criteria.direction}</li>
              <li><b>Queues:</b> {criteria.queues.length || "(any)"}</li>
              <li><b>Users:</b> {criteria.users.length || "(any)"}</li>
              <li><b>Work teams:</b> {criteria.workTeams.length || "(any)"}</li>
              <li><b>Wrap-up codes:</b> {criteria.wrapUpCodes.length || "(any)"}</li>
              <li><b>Skills:</b> {criteria.skills.length || "(any)"}</li>
              <li><b>Languages:</b> {criteria.languages.length || "(any)"}</li>
              <li><b>Duration:</b> {(criteria.minDurationSec ?? "-")} to {(criteria.maxDurationSec ?? "-")} sec</li>
              {criteria.useAdvanced && (
                <>
                  <li><b>Sentiment:</b> {criteria.useSentiment ? `${criteria.sentimentMin ?? ""} to ${criteria.sentimentMax ?? ""}` : "(off)"}</li>
                  <li><b>Topics inc/exc:</b> {criteria.includeTopics.length || "-"} / {criteria.excludeTopics.length || "-"}</li>
                  <li><b>Categories inc/exc:</b> {criteria.includeCategories.length || "-"} / {criteria.excludeCategories.length || "-"}</li>
                </>
              )}
            </ul>
          </div>
          <div>
            <h3 className="text-l
